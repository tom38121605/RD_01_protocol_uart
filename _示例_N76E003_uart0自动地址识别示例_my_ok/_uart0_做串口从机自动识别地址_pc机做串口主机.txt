 


注意1： 使用timer1，timer3做uart0，1的时钟源时，需关闭定时器的中断
注意2：因N76E003的uart有个32的预分频，波特率翻倍，就相当于预分频为16


说明1： 主机发0xff，可发送到任何从机
说明2： 从机的SADEN设为0，可接收任何主机的任何地址 
说明3： 在串口开着的时候，也可以随时更改从机的地址
说明5： SADDR和SADEN初始化为00H，当从机SADEN设为0，可接收任何主机的任何地址，相当于一个标准模式的串口


---------------------自动地址识别测试示例-----ok-------------

示例1： 如果把从机地址和掩码设置为下面的地址，则从机地址c0，c1 都可以识别，广播地址ff，fe也都可以识别，其他不能识别   

      SADDR =  0xc0;           //1100 0000
      SADEN =  0xfe;           //1111 1110
   
      //iaddrslave01 = 0xc1;    //1100 0001 
      //iaddrslave02 = 0xc0;    //1100 0000


Given与无关位（我的理解）：   （无关位的用途，就是把从机分组 -- 我的理解）
  
            本来那个位一定是0才能识别，被设无关后，0和1都可以识别，相当于可以识别2个地址，如果无关位为2位，则可识别4个地址

            //无关位对应的几个从机，可归类为一组，如： 1100 00x0 ，1100 000x 包括下面2个从机
            //1100 0001
            //1100 0010

            无关位对应的几个从机，可归类为一组，如： 1100 00x0 包括下面2个从机
            1100 0000
            1100 0010

            这两个从机，可同时用1100 0000寻址


广播地址1（由地址和掩码计算得出广播位）：   （实际应用已理解，原理先忽略跳过，对应用影响不大）

          把SADDR和SADEN或运算得出的值为广播地址，广播地址不止1个。结果中的零位被视为“无关”位。例如：

                  SADDR = 01010110b
                  SADEN = 11111100b
                  Broadcast = 1111111Xb    

           实际的广播地址如下： （无关位越多，广播地址越多）

                  Broadcast_addr01 = 11111110b
                  Broadcast_addr02 = 11111111b

广播地址2：  用0xff即可   （万能广播地址0xff）


说明1： 主机发0xff，可发送到任何从机
说明2： 从机的SADEN设为0，可接收任何主机的任何地址 


----------------------------------------


波特率最大值，最小值:

   timer1:  4.8K  - 1M  
   timer3:  0.11k - 1M

   最大值：  count =1，    波特率 为1MHz   （TH1=254）
   最小值timer1：  count =255， 波特率为3921hHz (实际应为4800， 对应TH1=255-1M/4800 = 47 )        --待验证  4800Hz
   最小值timer3：  count =65535， 波特率为15hHz (实际应为110， 对应THL=65535-1M/110 = 56444 )   --待验证  110Hz


。串口设置为模式1， 10位数据，一个起始位一个停止位; 打开串口接收
。波特率设置为翻倍
。 timer3做uart0的时钟源
 

--疑问1： 为什么uart0的时钟源选timer1时，没有TL1的设置（已明白：因为t1模式2是8位自动装载，t3是固有的16位自动装载）  
疑问2： 为什么count =  10^6 / 波特率  - 1  （后面的-1是什么含义）
疑问3： uart0如何选择sysclock为时钟源



--------------------波特率计算公式--------------------------（ 以波特率10K为例，接近9600)

1. 定时时间计算 (主时钟为16MHz，模式1，16位定时器)

   t = count *  1/(16*10^6)    秒
  示例： count为16000时，t=1ms

2. 计数值计算   (主时钟为16MHz，串口设置为模式1)

   count = t 秒 * ( 16*10^6 ) 
   示例： t为100us时 （波特率为10k）， count=1600

   即 count = 16 * 10^6 / 波特率  （这个是别的单片机的波特率算法）

3. 实际上， 在N76E003中，uart在模式1时， 有个32的预分频，还有个翻倍的2倍频，所以count计算如下：

   count = 16 * 10^6 *2 / 32 /波特率 = 10^6 / 波特率 

5. 计算波特率的最大值和最小值

   波特率 = 10^6 / count

   最大值：  count =1，    波特率 为1MHz   （TH1=254）
   最小值timer1：  count =255， 波特率为3921hHz (实际应为4800， 对应TH1=255-1M/4800 = 47 )   --待验证
   最小值timer3：  count =65535， 波特率为15hHz (实际应为110， 对应THL=65535-1M/110 = 56444 )   --待验证

 
===================================================


void main (void) 
 
   Set_All_GPIO_Quasi_Mode;   
   
   //AUXR1 |=1<<2;    
   

   //---------uart0 init----------------

   InitialUART0_Timer1(115200);
   //TI = 1;   
   
   SADDR =  0xc0;           //1100 0000
   SADEN =  0xfd;           //1111 1101
   
   //iaddrslave0 = 0xc2;    //1100 0010
   
   SCON = 0xd0;              //UART0 Mode3  
   SCON |= 1<<5;             //SM2=1 , 设置自动地址识别
   
    set_ES;              //IE.4=1,使能uart0中断   (包括tx和rx中断)
    set_EA;              //IE.7=1, 开全局中断   
   

   //iputs0("start\r\n");
   
   P16=0;   
   
   while(1) ;
  

----------------

//参数列表： iBaudrate
void InitialUART0_Timer3(iBaudrate)  
 
    P06_Quasi_Mode;         //P06 准双向
    P07_Quasi_Mode;         //P07 准双向      
    
   //---------------------uart0初始化------------------------------------------------

    //PCON &= ~(1<<6);   //PCON.6=0,  指定SCON.7 访问SM0位      //注意：这句是缺省隐形设置，要保留
    SCON = 0x50;     //SCON.7-6 = 01, SCON.4=1  串口设置为模式1， 10位数据，一个起始位一个停止位; 打开串口接收
                              //波特率 = t3溢出时间/32 (待理解)

    set_SMOD;             //PCON.7=1, 波特率翻倍

    T3CON &= 0xF8;     //T3CON.2-0 = 000, 不分频，即预分频为1
    set_BRCK;               //T3CON.5=1 ， uart0 的时钟源选择timer3
 

//---------------------t3初始化------------------------------------------------

    //设置T3的定时时间  （波特率  16 MHz）  ，timer3是自动装载定时器
    RH3    = HIBYTE(65536 - (1000000/iBaudrate)-1);  // 先跳过，待理解  
    RL3    = LOBYTE(65536 - (1000000/iBaudrate)-1);  // （已理解，因翻倍，波特率 = t3溢出时间/16， 所以公式中的16M改为1M）         
 
    //开启T3   
    set_TR3;         //T3CON.3=1, 开启T3

    //清串口发送中断标志
    set_TI;           //SCON.1 =1 , 串口发送中断标志清0   （uart1中必须要设置这句）




-------------------

//uart0中断响应函数
void SerialPort0_ISR(void) interrupt 4  
   
   if (RI==1)                  //SCON.0=1，rx中断
                                     
      clr_RI;                    //SCON.0=0, 清rx中断标志                     
   
      irxdata0 = SBUF;    //读取串口数据
      
      //Send_Data_To_UART0(irxdata0);
      
      P16=~P16; 
   
   if(TI==1)                 //SCON.1=1，tx中断
      clr_TI;                   //SCON.1=0，清tx中断标志
 




===========================参考=====================================

http://www.51hei.com/bbs/dpj-98785-1.html   //51黑 自动识别地址
















